% Included in tool.tex
\subsection{Direct Manipulation  Gesture Set}

\begin{table}[!b]
% % increase table row spacing, adjust to taste
\renewcommand{\arraystretch}{1.75}
% if using array.sty, it might be a good idea to tweak the value of
% \extrarowheight as needed to properly center the text within the cells
% \setlength{\extrarowheight}{10pt}
\centering
% % Some packages, such as MDW tools, offer better commands for making tables %
% than the plain LaTeX2e tabular which is used here.
\begin{tabular}{|p{3.8cm} |p{3.8cm} |}
\hline
\textbf{Algorithm Behavior} & \textbf{DM Gesture} \\
\hline
%Access a value & Grab value and drag elsewhere \\
%\hline
Use or copy an object's value & {\em drag-away}: Grab an object, and drag it
away quickly.
Drop it on the stage to create a new number with the same value.
\\
\hline
Remove an object from its parent (e.g. element from list, node from tree/graph) & {\em dwell-drag-away}: Grab an object, dwell for one second, then
drag it elsewhere.
\\
\hline
Compare two objects' values & {\em drag-into}: Drag one value into another.
\\
\hline
Assign one object's value to another &
{\em drag-into-dwell}: Drag one value into another, and
dwell until the desired interpretation (\texttt{=, +=, -=}) appears. \\
\hline
Insert a value into a list, or a node into a tree/graph
& {\em drag-insert}: Drag the value into a gap in the list, or the node to the
tip of an edge
\\

\hline
Attach an edge to a graph node
& {\em drag-edge}: Drag the edge's start or end handle to the node.
\\

\hline
Mark a list element or tree/graph node (e.g. as sorted or visited) &
{\em fill}: Select the ``Fill" tool, and click on the element. \\
\hline
\end{tabular}

\caption{CodeInk's Direct Manipulation (DM) Gesture Set}
\label{tbl:gesture_table}

\end{table}

CodeInk's DM gesture set (summarized in \tab{tbl:gesture_table} and explored in detail in ~\cite{Scott2014}) enables
tracing algorithms by manipulating numbers, lists, binary trees and
graphs. Observation of skilled classroom instructors  provided a list of algorithm behaviors needed for tracing common sorting and search algorithms (left
column of \tab{tbl:gesture_table}).
We devised a DM gesture ~\cite{Shneiderman1982, Lee2012} for each behavior, enabling the user to
express the behavior with a physical action. For example, numbers can be
copied by grabbing them and dragging away, and can be inserted into lists
by dragging them into gaps between other list elements.

The gesture set is both compact (7 gestures) and
expressive: dragging one object into another compares their numeric
values, regardless of whether they are numbers, list elements, nodes or
some mixture thereof. Similarly, popping a list element or detaching a
subtree from its parent is accomplished by grabbing and holding 
(\emph{dwelling}) until it can be moved away freely. Two examples help to illustrate
the gesture set: insertion sort and AVL insertion.

\noindent \textbf{Insertion Sort}: Insertion sort is typically illustrated by redrawing a concrete example in successive
configurations (\fig{fig:6006-insertion}). With CodeInk, the algorithm
behavior can be illustrated more directly:

\noindent 1) Drag an example list onto the stage and enter
%%% don’t call it both a stage and a main canvas. Find one term. (And if there
%%% is a main canvas then there must be a secondary canvas?
numbers to initialize element values. (Green arrows in the figures indicate user drag
actions and are just for illustration here).

\vspace{-0.25em}
\noindent \includegraphics[width=0.7\columnwidth]{img/examples/insertion-1.png}
\vspace{0.5em}

\noindent 2) To prepare to move the ``2" element, grab and hold it  for
at least one second. (A blue circle fills up to give the user
feedback on how long they have dwelled.)

\vspace{-0.25em}
\noindent \includegraphics[width=0.7\columnwidth]{img/examples/insertion-2.png}
\vspace{0.4em}

\noindent 3) After one second, the
list expands outward, creating gaps into which a new element can be inserted. The
``2" element is now ready to be moved.

\vspace{-0.25em}
\noindent \includegraphics[width=0.7\columnwidth]{img/examples/insertion-3.png}
\vspace{0.5em}

\noindent 4) Drag the ``2" to the left until it hits the ``5" element, which
adds a numeric comparison step (``2 $<$ 5") to the trace.

\vspace{-0.25em}
\noindent \includegraphics[width=0.7\columnwidth]{img/examples/insertion-4.png}
\vspace{0.5em}

\noindent 5) Keep moving the ``2" to the left of the ``5" element.

\vspace{-0.25em}
\noindent \includegraphics[width=0.7\columnwidth]{img/examples/insertion-5.png}
\vspace{0.5em}

\noindent 6) Once the correct position is found, drop the element,
the list collapses into its new, rearranged state (with the
``2" preceeding the ``5'') and CodeInk adds a list insertion step to the trace. 

\noindent \includegraphics[width=0.7\columnwidth]{img/examples/insertion-6.png}

The rest of insertion sort is traced by moving the finger down the
list and inserting elements into the sorted sublist until the entire
list is sorted. If any mistakes are occur, the user can undo steps to
remove them from the trace.


\noindent \textbf{AVL Insertion}: Drawing a balanced binary search
tree insertion can be tedious and error-prone, because rotations
require redrawing the entire tree in a new configuration. CodeInk's
gesture set allows users to rearrange nodes in the tree by
detaching, dragging, and reattaching them. As with lists,
dragging one value into another triggers a numeric comparison (Step 2),
and grabbing and dwelling removes a child from its parent (Step 5).


\noindent \begin{tabular}{m{4.6cm} m{3.4cm}}

1) Create two new binary tree nodes (``4" and ``6") by dragging node
objects onto the stage and typing in their numeric values.

& \includegraphics[width=3.4cm]{img/examples/bst-1.png}
\end{tabular}


\noindent \begin{tabular}{m{4.6cm} m{3.4cm}}

2) Drag the ``6'' node into the ``4'' node to compare their values.
CodeInk adds the comparison step (``4 $<$ 6") to the trace.

& \includegraphics[width=3.4cm]{img/examples/bst-2.png}
\end{tabular}

\noindent \begin{tabular}{m{6.2cm} m{1.8cm}}

3) Since ``6" is greater than ``4", keep dragging the ``6'' along the
right pointer of the ``4" node. This gesture temporarily highlights the pointer
(turning it blue) and adds a \emph{pointer traversal} step to the trace.

& \includegraphics[width=1.8cm]{img/examples/bst-3.png}
\end{tabular}

\noindent \begin{tabular}{m{4.6cm} m{3.4cm}}

4) Keep dragging along the right pointer until reaching its tip. The
``6" node now re-emerges as the right child of ``4." The node is colored blue to
preview the insertion. Release the node to confirm the insertion and
add the step \texttt{binary1.right = binary2} to the trace.

& \includegraphics[width=3.4cm]{img/examples/bst-4.png}
\end{tabular}

\noindent \begin{tabular}{m{4.6cm} m{3.4cm}}

5) Next insert a new ``9" node into the tree, which results in an
unbalanced tree. Now demonstrate a rotation by grabbing the ``6" node,
dwelling for one second, and dragging it away to detach the subtree.
When the subtree is dropped on the stage, a new step is added to the
trace: \texttt{binary1.right = None}

& \includegraphics[width=3.4cm]{img/examples/bst-5.png}
\end{tabular}

\noindent \begin{tabular}{m{4.6cm} m{3.4cm}}

6) The ``6 / 9" subtree is now separated from the ``4." Drag the ``4"
node downward ...

& \includegraphics[width=3.4cm]{img/examples/bst-6.png}
\end{tabular}

\noindent \begin{tabular}{m{4.6cm} m{3.4cm}}

7) ... until it reaches the tip of the ``6" node's left pointer. Then
release to insert it there and balance the tree, which adds the step
\texttt{binary2.left = binary1} to the trace.

& \includegraphics[width=3.4cm]{img/examples/bst-7.png}
\end{tabular}

\begin{comment}
\noindent \textbf{Graph algorithms}: Our gesture set also covers graph
traversal, such as search or finding shortest paths (see
\fig{fig:example-dijkstra}). It supports creating and attaching graph
nodes and edges, updating node and edge values, and marking nodes as
visited. Here is how to trace Dijkstra's algorithm using CodeInk:

\noindent \begin{tabular}{m{4.2cm} m{3.8cm}}
1) Create an example graph by dragging and dropping node and edge
objects onto the stage, typing in the numeric node costs and edge weights.
Edges can be connected to nodes by clicking and dragging their start and end
handles.
& \includegraphics[width=3.8cm]{img/examples/dijkstra-1.png}
\end{tabular}

\noindent \begin{tabular}{m{4.2cm} m{3.8cm}}
2) Start with \texttt{node1}. To calculate the
cost of reaching its neighbor \texttt{node2},
first drag \texttt{node1} (source node) and drop it onto the stage, which
creates a new number (\texttt{num1}) equal to the node's cost (\texttt{0}).
& \includegraphics[width=3.8cm]{img/examples/dijkstra-2.png}
\end{tabular}

\noindent \begin{tabular}{m{4.2cm} m{3.8cm}}
3) Now drag the weight of the connecting edge into the current cost
(\texttt{num1}), which triggers a comparison by default. However, a
comparison is not the correct operation; the two values
must be added.
& \includegraphics[width=3.8cm]{img/examples/dijkstra-3.png}
\end{tabular}

\noindent \begin{tabular}{m{4.2cm} m{3.8cm}}
4) Dwelling after the drag-into gesture causes CodeInk to cycle through alternative
interpretations. When an addition assignment
operation (\texttt{+=}) appears, release to end the gesture. The cost
updates to the value of \texttt{10} (\texttt{num1 += edge1.weight}).
& \includegraphics[width=3.8cm]{img/examples/dijkstra-4.png}
\end{tabular}

\noindent \begin{tabular}{m{4.2cm} m{3.8cm}}
5) Now drag \texttt{num1} into \texttt{node2}
to trigger a comparison, checking if the new cost is less than
the existing cost of reaching that node.
& \includegraphics[width=3.8cm]{img/examples/dijkstra-5.png}
\end{tabular}

\noindent \begin{tabular}{m{4.2cm} m{3.8cm}}
6) Since \texttt{10 $<$ $\infty$}, dwell to cycle to the assignment
expression (\texttt{node2.value = num1}). Releasing ends the gesture, and updates the cost
of \texttt{node2} to 10.
& \includegraphics[width=3.8cm]{img/examples/dijkstra-6.png}
\end{tabular}

\noindent \begin{tabular}{m{4.2cm} m{3.8cm}}
7) Repeat on all nodes and mark each one as visited by
selecting ``Fill" and clicking on that node.
& \includegraphics[width=3.8cm]{img/examples/dijkstra-7.png}
\end{tabular}

%Because the drag-into gesture has multiple interpretations
%(comparison, assignment, addition assignment), the user can dwell
%to cycle through all interpretations (see \sec{sec:overloaded-gestures}).
\end{comment}

\subsection{Chaining and traversal patterns}
In CodeInk, the user can chain multiple gestures while dragging an object to
describe a traversal pattern. For example, during insertion sort, the user can
drag an element along the list, performing comparisons without releasing it
until the correct location is found. Similarly, during an AVL insertion, a
candidate node is dragged through the tree to make comparisons and follow
pointers to find the insertion point.

One subtle interaction issue is deciding which behaviors in a chain of
gestures to add to the trace. For example, the user should be
allowed to click and drag an element into a list, then undo the behavior
by dragging it back out before releasing the mouse button. The insertion
step should be added to the trace only if the new value is released into the
list, but comparison steps should be committed as the user is dragging the
element during a traversal. We therefore distinguish 
\emph{mutation} and \emph{observation} behaviors, according to whether they affect
the underlying data (mutation) or only visualize decision making(observation).. In a chain of gestures, observations are continuously committed to the trace, while
mutationsare committed only at the end of a
gesture.

\subsection{Resolving overloaded gestures}
\label{sec:overloaded-gestures}

A DM gesture can be overloaded, i.e., have more than one behavior associated with it. Drag-into, for example can indicate either a comparison or an assignment. In keeping with its overall spirit, CodeInk resolves the ambiguity gesturally (i.e., depending on dwell), an issue we explore this in more detail in \cite{Scott2014}.



