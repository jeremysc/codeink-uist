\section{Related Work}

Code-driven visualization tools~\cite{Guo2013, Sorva2013} enable users to enter
code that implements an algorithm, and watch a step-by-step animation of its
execution. While these tools are powerful for understanding code snippets, they
are not ideal for understanding an algorithm's high-level behavior because the
input code must be language-specific. On the other hand, algorithm
visualizations~\cite{AlgoViz} are custom-built animations that operate at the
proper level of abstraction, but they must be hand-coded for a particular
algorithm. CodeInk offers an alternative, low-effort method of authoring
visualizations, and also enables students to play the role of the computer and
actively trace the algorithm's behavior. Compared to passively viewing visualizations,
tracing is an example of active learning, which has been shown
to result in better pedagogical outcomes~\cite{Sorva2012Diss}.

% Sorva et al.\ provide a comprehensive survey of 44 such tools
% for languages such as Java, C++, and Python~\cite{Sorva2013}.

%To enable teachers to find and integrate suitable
%visualizations into their curriculula, Shaffer et al.\ created the AlgoViz
%Portal~\cite{AlgoViz}, a website that catalogues and ranks hundreds of existing
%visualizations.

%Shaffer et al.\ surveyed CS instructors and found that while there was high interest in these visualizations, 
% few used them in practice due to the difficulty of finding and integrating
% suitable visualizations into their curriculum~\cite{Shaffer2011}.

Visual programming languages enable programmers to write programs by directly
manipulating graphical elements rather than by typing text. These languages have
gained widespread adoption in two main areas:
(1) domain-specific languages for technical specialists (e.g. LabVIEW, Max/MSP),
% such as LabVIEW for electronic systems designers and Max/MSP for digital music
% creators
and (2) educational programming environments such as Alice~\cite{Alice2008} and
Scratch~\cite{Scratch2008}, which allow novices to create simple programs by
snapping together colorful blocks. CodeInk introduces a new visual
language for education that enables users to trace algorithms by
manipulating data structures.

\begin{comment}
Direct manipulation (DM) user interfaces~\cite{Hutchins1985}, starting with
Shneiderman's initial definiton of the term~\cite{Shneiderman1982}, have long
been recognized to promote more satisfactory reactions among users than
command-line or WIMP interfaces. CodeInk's DM gesture set was designed with
these princples in mind: algorithm steps can be described using physical actions
(grabbing and dragging data structures), lowering the degree of indirection
between onscreen objects and the abstract data structures they represent. For
example, list elements can be rearranged by grabbing elements and moving them
into new positions, rather than by writing code or using menus.
\end{comment}

% DM environments for programming by
%demonstration~\cite{Cypher1993} enable users to construct programs by
%demonstrating how the program should behave on specific examples, from which
%% the system refines its understanding of the program. CodeInk's focus is on
% traces of
%algorithms, rather than general programs.


\begin{comment}
Programming by example~\cite{Lieberman2001} enables the user to write programs by
providing example input-output pairs. A related technique, programming by
demonstration~\cite{Cypher1993}, lets the user demonstrate individual steps
using a direct manipulation UI. Tools that embody these techniques often
generalize the user's actions to synthesize programs that operate on new,
unknown inputs~\cite{Yessenov2013, Kandel2011}.
% Common use cases include synthesizing text editing~\cite{Yessenov2013} and
% data cleaning~\cite{Kandel2011} scripts.
CodeInk takes inspiration from these tools and allows the user to explain
algorithms by demonstration, rather than by writing code. CodeInk does not yet
provide generalization capabilities; we plan to add that in future work.
\end{comment}
